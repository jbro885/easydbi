// Generated by CoffeeScript 1.12.5
(function() {
  var Driver, Errorlet, EventEmitter, Promise, QueryArgs, QueryKey, ResultRecord, ResultSet, Schema, _, debug, fs, knex, path,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  Promise = require('bluebird');

  fs = Promise.promisifyAll(require('fs'));

  path = require('path');

  Errorlet = require('errorlet');

  _ = require('lodash');

  debug = require('debug')('easydbi');

  Schema = require('schemalet');

  knex = require('knex');

  QueryKey = Schema.makeSchema({
    type: 'string'
  });

  QueryArgs = Schema.makeSchema({
    type: 'object',
    defaultProc: function() {
      return {};
    }
  });

  ResultRecord = Schema.makeSchema({
    type: 'object'
  });

  ResultSet = Schema.makeSchema({
    type: 'array',
    items: ResultRecord
  });

  Driver = (function(superClass) {
    extend(Driver, superClass);

    Driver.id = 0;

    Driver.pool = true;

    function Driver(key1, options) {
      this.key = key1;
      this.options = options;
      this.constructor.id++;
      this.id = this.constructor.id;
    }

    Driver.prototype.connect = Schema.makeFunction({
      params: [],
      async: true
    }, function(cb) {
      return this.innerConnect(cb);
    });

    Driver.prototype.isConnected = Schema.makeFunction({
      params: [],
      returns: {
        type: 'boolean'
      }
    }, function() {
      return this.innerIsConnected();
    });

    Driver.prototype.driverName = Schema.makeFunction({
      params: [],
      returns: {
        type: 'string'
      }
    }, function() {
      return this.constructor.name;
    });

    Driver.prototype.loadScript = Schema.makeFunction({
      params: [
        {
          type: 'string'
        }, {
          type: 'boolean',
          "default": false
        }
      ],
      async: true
    }, function(filePath, inTrans, cb) {
      var self;
      debug('DBI.Driver.loadScript', {
        filePath: filePath,
        inTrans: inTrans
      });
      self = this;
      return fs.readFileAsync(filePath, 'utf8').then(function(data) {
        var cmds;
        cmds = _.filter(data.split(/\s*;\s*/), function(cmd) {
          return cmd.trim() !== '';
        });
        if (inTrans) {
          return self.beginAsync().then(function() {
            return Promise.each(cmds, function(cmd) {
              return self.execAsync(cmd, {});
            });
          }).then(function() {
            return self.commitAsync();
          })["catch"](function(e) {
            return self.rollback(function() {
              return cb(e);
            });
          });
        } else {
          return Promise.each(cmds, function(cmd) {
            return self.execAsync(cmd, {});
          });
        }
      }).then(function() {
        return cb(null);
      })["catch"](cb);
    });

    Driver.prototype.isKnexQueryBuilder = function(key) {
      return key instanceof Object && key.client && key._statements instanceof Array;
    };

    Driver.prototype.isValidQueryType = function(key) {
      return typeof key === 'string' || this.isKnexQueryBuilder(key);
    };

    Driver.prototype.query = function(key, args, cb) {
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      if (!this.isValidQueryType(key)) {
        return cb(Errorlet.create({
          error: 'invalid_query_type',
          method: 'EASYDBI.query',
          query: key,
          message: 'must be string or Knex Query Builder object'
        }));
      }
      return this.innerQuery(key, args, function(err, results) {
        if (err) {
          return cb(Errorlet.create({
            error: 'queryError',
            method: 'EASYDBI.query',
            query: key,
            args: args,
            __inner: err
          }));
        } else {
          return cb(null, results);
        }
      });
    };

    Driver.prototype.queryOne = function(key, args, cb) {
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      if (!this.isValidQueryType(key)) {
        return cb(Errorlet.create({
          error: 'invalid_query_type',
          method: 'EASYDBI.query',
          query: key,
          message: 'must be string or Knex Query Builder object'
        }));
      }
      return this.query(key, args, function(err, rows) {
        if (err) {
          cb(err);
        }
        if ((rows != null ? rows.length : void 0) === 0) {
          return cb(Errorlet.create({
            error: 'no_rows_found',
            method: 'EASYDBI.queryOne',
            query: key,
            args: args
          }));
        } else if ((rows != null ? rows.length : void 0) > 0) {
          return cb(null, rows[0]);
        } else {
          return cb(Errorlet.create({
            error: 'unknown_result',
            method: 'EASYDBI.queryOne',
            query: key,
            args: args,
            result: rows
          }));
        }
      });
    };

    Driver.prototype.innerExec = function(key, args, cb) {
      return this.innerQuery(key, args, cb);
    };

    Driver.prototype.exec = function(key, args, cb) {
      if (arguments.length === 2) {
        cb = args;
        args = {};
      }
      if (!this.isValidQueryType(key)) {
        return cb(Errorlet.create({
          error: 'invalid_query_type',
          method: 'EASYDBI.query',
          query: key,
          message: 'must be string or Knex Query Builder object'
        }));
      }
      return this.innerExec(key, args, function(err, rows) {
        if (err) {
          return cb(err);
        } else {
          return cb(null);
        }
      });
    };

    Driver.prototype.begin = Schema.makeFunction({
      async: true,
      params: []
    }, function(cb) {
      return this.innerBegin(cb);
    });

    Driver.prototype.innerBegin = function(cb) {
      return this.exec('begin', cb);
    };

    Driver.prototype.commit = Schema.makeFunction({
      async: true,
      params: []
    }, function(cb) {
      return this.innerCommit(cb);
    });

    Driver.prototype.innerCommit = function(cb) {
      return this.exec('commit', cb);
    };

    Driver.prototype.rollback = Schema.makeFunction({
      async: true,
      params: []
    }, function(cb) {
      return this.innerRollback(cb);
    });

    Driver.prototype.innerRollback = function(cb) {
      return this.exec('rollback', cb);
    };

    Driver.prototype.disconnect = function(cb) {
      return this.innerDisconnect(cb);
    };

    Driver.prototype.close = function(cb) {
      return this.innerClose(cb);
    };

    Driver.prototype.execScript = Schema.makeFunction({
      async: true,
      params: [
        {
          type: 'string'
        }
      ]
    }, function(filePath, cb) {
      var self;
      self = this;
      return fs.readFileAsync(filePath, 'utf8').then(function(data) {
        var queries;
        queries = data.split(/\w*;\w/);
        return Promise.each(queries, function(query) {
          console.log('try', query);
          return self.execAsync(query, {});
        });
      }).then(function() {
        return cb(null);
      })["catch"](cb);
    });

    return Driver;

  })(EventEmitter);

  Promise.promisifyAll(Driver.prototype);

  module.exports = Driver;

}).call(this);
